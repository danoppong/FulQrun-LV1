import { NextRequest, NextResponse } from 'next/server'
import { createServerClient } from '@/lib/supabase'
import { SharePointIntegration } from '@/lib/integrations/sharepoint'

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const organizationId = searchParams.get('organizationId')
    const siteId = searchParams.get('siteId')
    const folderPath = searchParams.get('folderPath') || '/'
    const opportunityId = searchParams.get('opportunityId')

    if (!organizationId || !siteId) {
      return NextResponse.json(
        { error: 'Organization ID and Site ID are required' },
        { status: 400 }
      )
    }

    const supabase = createServerClient()

    // Get SharePoint connection
    const { data: connection, error: connectionError } = await supabase
      .from('integration_connections')
      .select('*')
      .eq('organization_id', organizationId)
      .eq('integration_type', 'sharepoint')
      .eq('status', 'active')
      .single()

    if (connectionError || !connection) {
      return NextResponse.json(
        { error: 'SharePoint not connected' },
        { status: 404 }
      )
    }

    const credentials = JSON.parse(connection.credentials)
    const sharepoint = new SharePointIntegration(credentials.access_token)

    let documents: Array<{ id: string; name: string; url: string; size?: number; modified?: string }> = []

    if (opportunityId) {
      // Get PEAK process documents for specific opportunity
      documents = await sharepoint.getPEAKDocuments(siteId, opportunityId)
    } else {
      // Get documents from specific folder
      documents = await sharepoint.getDocumentsFromSite(siteId, folderPath)
    }

    // Store document references in database
    if (documents.length > 0 && opportunityId) {
      const documentRecords = documents.map(doc => ({
        opportunity_id: opportunityId,
        document_id: doc.id,
        name: doc.name,
        url: doc.url,
        size: doc.size,
        last_modified: doc.lastModified,
        created_by: doc.createdBy,
        web_url: doc.webUrl,
        download_url: doc.downloadUrl,
        thumbnail_url: doc.thumbnailUrl
      }))

      // Upsert document records
      for (const record of documentRecords) {
        await supabase
          .from('sharepoint_documents')
          .upsert(record, { onConflict: 'opportunity_id,document_id' })
      }
    }

    return NextResponse.json(documents)
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch SharePoint documents' },
      { status: 500 }
    )
  }
}

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData()
    const organizationId = formData.get('organizationId') as string
    const siteId = formData.get('siteId') as string
    const folderPath = formData.get('folderPath') as string || '/'
    const opportunityId = formData.get('opportunityId') as string
    const file = formData.get('file') as File

    if (!organizationId || !siteId || !file) {
      return NextResponse.json(
        { error: 'Organization ID, Site ID, and file are required' },
        { status: 400 }
      )
    }

    const supabase = createServerClient()

    // Get SharePoint connection
    const { data: connection, error: connectionError } = await supabase
      .from('integration_connections')
      .select('*')
      .eq('organization_id', organizationId)
      .eq('integration_type', 'sharepoint')
      .eq('status', 'active')
      .single()

    if (connectionError || !connection) {
      return NextResponse.json(
        { error: 'SharePoint not connected' },
        { status: 404 }
      )
    }

    const credentials = JSON.parse(connection.credentials)
    const sharepoint = new SharePointIntegration(credentials.access_token)

    // Upload document
    const fileBuffer = await file.arrayBuffer()
    const result = await sharepoint.uploadDocumentToSite(
      siteId,
      folderPath,
      file.name,
      fileBuffer,
      file.type
    )

    if (!result.success) {
      return NextResponse.json(
        { error: result.error || 'Upload failed' },
        { status: 500 }
      )
    }

    // Store document reference in database
    if (opportunityId) {
      const documentRecord = {
        opportunity_id: opportunityId,
        document_id: result.documentId!,
        name: file.name,
        url: result.url!,
        size: file.size,
        last_modified: new Date().toISOString(),
        created_by: 'Current User', // This should come from auth
        web_url: result.url!,
        download_url: result.url! // This should be the actual download URL
      }

      await supabase
        .from('sharepoint_documents')
        .upsert(documentRecord, { onConflict: 'opportunity_id,document_id' })
    }

    return NextResponse.json({
      success: true,
      document: {
        id: result.documentId,
        name: file.name,
        url: result.url,
        size: file.size
      }
    })
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to upload document' },
      { status: 500 }
    )
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const organizationId = searchParams.get('organizationId')
    const siteId = searchParams.get('siteId')
    const documentId = searchParams.get('documentId')
    const opportunityId = searchParams.get('opportunityId')

    if (!organizationId || !siteId || !documentId) {
      return NextResponse.json(
        { error: 'Organization ID, Site ID, and Document ID are required' },
        { status: 400 }
      )
    }

    const supabase = createServerClient()

    // Get SharePoint connection
    const { data: connection, error: connectionError } = await supabase
      .from('integration_connections')
      .select('*')
      .eq('organization_id', organizationId)
      .eq('integration_type', 'sharepoint')
      .eq('status', 'active')
      .single()

    if (connectionError || !connection) {
      return NextResponse.json(
        { error: 'SharePoint not connected' },
        { status: 404 }
      )
    }

    const credentials = JSON.parse(connection.credentials)
    const sharepoint = new SharePointIntegration(credentials.access_token)

    // Delete document from SharePoint
    const success = await sharepoint.deleteDocument(siteId, documentId)

    if (!success) {
      return NextResponse.json(
        { error: 'Failed to delete document from SharePoint' },
        { status: 500 }
      )
    }

    // Remove document reference from database
    if (opportunityId) {
      await supabase
        .from('sharepoint_documents')
        .delete()
        .eq('opportunity_id', opportunityId)
        .eq('document_id', documentId)
    }

    return NextResponse.json({
      success: true,
      message: 'Document deleted successfully'
    })
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to delete document' },
      { status: 500 }
    )
  }
}
