import { createClient } from '@supabase/supabase-js'
import { supabaseConfig } from '@/lib/config'
import { Database } from '@/lib/supabase'

// Types for better type safety
export type AuthUser = {
  id: string
  email: string | undefined
  profile?: {
    id: string
    email: string
    full_name: string | null
    role: 'rep' | 'manager' | 'admin'
    organization_id: string
    learning_progress: Record<string, any>
    created_at: string
    updated_at: string
  }
}

export type AuthSession = {
  user: AuthUser
  access_token: string
  refresh_token: string
}

// Client-side authentication service
export class AuthClientService {
  private static clientInstance: ReturnType<typeof createClient> | null = null

  /**
   * Get or create client-side Supabase client
   * Uses singleton pattern to prevent multiple instances
   * Always returns a valid client (never null)
   */
  static getClient(): any {
    if (this.clientInstance) {
      return this.clientInstance
    }

    if (!supabaseConfig.isConfigured) {
      // Return mock client for development
      this.clientInstance = this.createMockClient()
      return this.clientInstance
    }

    try {
      this.clientInstance = createClient(
        supabaseConfig.url!,
        supabaseConfig.anonKey!,
        {
          auth: {
            persistSession: true,
            storage: typeof window !== 'undefined' ? window.localStorage : undefined,
            autoRefreshToken: true,
            detectSessionInUrl: true
          }
        }
      )
    } catch (error) {
      console.error('Failed to create Supabase client:', error)
      this.clientInstance = this.createMockClient()
    }

    return this.clientInstance
  }

  /**
   * Get current authenticated user with profile
   */
  static async getCurrentUser(): Promise<AuthUser | null> {
    const supabase = this.getClient()
    const { data: { user }, error } = await supabase.auth.getUser()
    
    if (error || !user) {
      return null
    }

    // Get user profile from our users table
    const { data: profile } = await supabase
      .from('users')
      .select('*')
      .eq('id', user.id)
      .single()

    return { ...user, profile: profile || undefined } as AuthUser
  }

  /**
   * Require authentication - throws if not authenticated
   */
  static async requireAuth(): Promise<AuthUser> {
    const user = await this.getCurrentUser()
    if (!user) {
      throw new Error('Authentication required')
    }
    return user
  }

  /**
   * Require specific role - throws if not authorized
   */
  static async requireRole(allowedRoles: string[]): Promise<AuthUser> {
    const user = await this.getCurrentUser()
    if (!user?.profile) {
      throw new Error('Authentication required')
    }
    
    if (!allowedRoles.includes(user.profile.role)) {
      throw new Error('Insufficient permissions')
    }
    
    return user
  }

  /**
   * Get organization for current user
   */
  static async getCurrentOrganization() {
    const user = await this.getCurrentUser()
    if (!user?.profile) return null

    const supabase = this.getClient()
    const { data: organization } = await supabase
      .from('organizations')
      .select('*')
      .eq('id', user.profile.organization_id)
      .single()

    return organization
  }

  /**
   * Create mock client for development/testing
   */
  private static createMockClient(): any {
    return {
      auth: {
        getUser: async () => ({ 
          data: { user: null }, 
          error: { message: 'Supabase not configured' } 
        }),
        signInWithPassword: async () => ({ 
          data: { user: null }, 
          error: { message: 'Supabase not configured' } 
        }),
        signUp: async () => ({ 
          data: { user: null }, 
          error: { message: 'Supabase not configured' } 
        }),
        signOut: async () => ({ error: null }),
        signInWithOAuth: async () => ({ 
          error: { message: 'Supabase not configured' } 
        }),
        onAuthStateChange: (callback: any) => ({
          data: { subscription: { unsubscribe: () => {} } }
        })
      },
      from: (table: string) => ({
        select: () => ({
          eq: () => ({
            single: async () => ({ data: null, error: { message: 'Database not configured' } })
          }),
          order: () => ({
            single: async () => ({ data: null, error: { message: 'Database not configured' } })
          })
        }),
        insert: (data: any) => {
          const result = { data: null, error: { message: 'Database not configured' } }
          const promise = Promise.resolve(result)
          return Object.assign(promise, {
            select: () => ({
              single: async () => result
            })
          })
        },
        update: () => ({
          eq: () => ({
            select: () => ({
              single: async () => ({ data: null, error: { message: 'Database not configured' } })
            })
          })
        }),
        delete: () => ({
          eq: async () => ({ error: { message: 'Database not configured' } })
        })
      })
    } as unknown as any
  }
}

// Export convenience functions for backward compatibility
export const createClientComponentClient = () => AuthClientService.getClient()
export const getUser = () => AuthClientService.getCurrentUser()
export const requireAuth = () => AuthClientService.requireAuth()
export const requireRole = (roles: string[]) => AuthClientService.requireRole(roles)
export const getOrganization = () => AuthClientService.getCurrentOrganization()
